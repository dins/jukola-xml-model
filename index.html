<!doctype html>
<html lang="en">
<head>
    <title>Jukola Vaihtoajat</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
          integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-141811127-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-141811127-1');
    </script>
    <script src="web-lib/jstat.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" crossorigin="anonymous"></script>
    <script src="web-lib/lodash-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.bundle.min.js"></script>
    <script src="web-lib/chartjs-plugin-annotation.min.js"></script>
    <style>
        h1 {
            margin: 20px;
        }

        #estimate-summary {
            margin: auto;
            width: auto;
        }

        .finished .estimate {
            color: grey;
            text-decoration: line-through;
        }

        .finish-time {
            color: green;
            font-weight: bold;
        }

        .unfinished .estimate {
            font-style: italic;
        }

    </style>
</head>
<body>
<h1>Jukola Vaihtoajat</h1>

<table class="table" id="estimate-summary">
    <thead>
    <tr>
        <th scope="col">Osuus</th>
        <th scope="col">Nimi</th>
        <th scope="col">Ennustettu aikaväli</th>
        <th scope="col">Ennustettu maaliintulo</th>
        <th scope="col">Maalissa</th>
        <th scope="col">Yhteislähdön todennäköisyys</th>
        <th scope="col">Osuuden aikana on pimeää</th>
    </tr>
    </thead>
    <tbody>
    </tbody>
</table>

<canvas id="chartjs-plot" width="300" height="250"></canvas>

<script>

  var raceStart = {
    ve: new Date(Date.parse('2019-06-15T14:00:00+03:00')), // parse returns something else than Date
    ju: new Date(Date.parse('2019-06-15T23:00:00+03:00'))
  }

  function raceMinutesToDate(minutesSinceRaceStart, ve_or_ju, teamsLatestOnlineTimestamp) {
    var raceSatartTime = raceStart[ve_or_ju]
    if (teamsLatestOnlineTimestamp) {
      raceSatartTime = new Date(teamsLatestOnlineTimestamp)
    }
    // create new to not modify the original
    return new Date(raceSatartTime).setMinutes(raceSatartTime.getMinutes() + minutesSinceRaceStart)
  }

  function produceDataPoints(logMeans, logStds, ve_or_ju, teamsLatestOnlineTimestamp) {
    var indexes = Array.from(Array(2000).keys())
    var wholeRange = _.map(indexes, function (i) {
      var min = i * 2
      var propability = jStat.lognormal.pdf(min, logMeans, logStds)
      var finishTime = raceMinutesToDate(min, ve_or_ju, teamsLatestOnlineTimestamp)
      return {x: finishTime, y: propability}
    })
    // Remove points where propability is too low for printing
    return _.filter(wholeRange, function (point) {
      return point.y > 0.00001
    })
  }

  function timestampToDate(utcTimestamp) {
    return new Date(utcTimestamp)
  }

  function formatTime(utcTimestamp) {
    function pad(number) {
      if (number < 10) {
        return '0' + number;
      }
      return number;
    }

    var date = timestampToDate(utcTimestamp);
    return pad(date.getHours()) + ":" + pad(date.getMinutes())
  }

  function formatPercent(floatPropability) {

    return (floatPropability * 100).toFixed(0) + '%'
  }

  function addRunnerToTable(runner) {
    var rowClass = ""
    var intervalText = formatTime(runner.fin_time_start95) + " - " + formatTime(runner.fin_time_end95);
    if (runner.onlineFinishTimestampLow95) {
      intervalText = formatTime(runner.onlineFinishTimestampLow95) + " - " + formatTime(runner.onlineFinishTimestampHigh95);
    }

    var pointEstimateText = formatTime(runner.fin_time_median);
    if (runner.onlineFinishTimestampMean) {
      pointEstimateText = formatTime(runner.onlineFinishTimestampMean);
      rowClass = "unfinished"
    }
    var finishTime = ""
    if (runner.lastControlType === "Finish") {
      finishTime = formatTime(runner.lastControlTimestamp)
      rowClass = "finished"
    }
    $("#estimate-summary tbody").append(
      "<tr class=" + rowClass + "><th scope=\"row\">" + runner.leg
      + "</th><td>" + runner.name
      + "</td><td class=estimate>" + intervalText
      + "</td><td class=estimate>" + pointEstimateText
      + "</td><td class=finish-time>" + finishTime
      + "</td><td class=estimate>" + formatPercent(runner.mass_start)
      + "</td><td class=estimate>" + formatPercent(runner.dark_during_leg)
      + "</td></tr>")
  }

  function showTeam(teamId, teamRunners, ve_or_ju) {
    console.log("teamId", teamId)
    console.log("teamRunners", teamRunners)

    _.each(teamRunners, addRunnerToTable)

    var colors = {
      blue: "rgb(54, 162, 235)",
      green: "rgb(75, 192, 192)",
      grey: "rgb(201, 203, 207)",
      orange: "rgb(255, 159, 64)",
      purple: "rgb(153, 102, 255)",
      red: "rgb(255, 99, 132)",
      yellow: "rgb(255, 205, 86)"
    }
    var colorNames = Object.keys(colors)
    var unFinishedRunners = _.filter(teamRunners, function (runner) {
      return runner.lastControlType !== "Finish"
    })
    var finishedRunners = _.filter(teamRunners, function (runner) {
      return runner.lastControlType === "Finish"
    })

    var teamDatasets = _.map(teamRunners, function (runner) {
      var color = colors[colorNames[runner.leg - 1]]
      var logMinsToFinish = runner.logMeanTimeLeft || runner.fin_sum_log_mean
      var logMinsStdToFinish = runner.logsStdevTimeLeft || runner.fin_sum_log_std
      var dataPoints = produceDataPoints(logMinsToFinish, logMinsStdToFinish, ve_or_ju, runner.teamsLatestOnlineTimestamp)
      return {
        type: 'line',
        label: runner.leg + " " + runner.name,
        backgroundColor: color,
        borderColor: color,
        data: dataPoints,
        fill: false,
        pointRadius: 1
      }
    })
    var staticDatasets = []
    /*    var staticDatasets = _.map(teamRunners, function (runner) {
          var color = colors[colorNames[runner.leg - 1]]
          var logMinsToFinish = runner.fin_sum_log_mean
          var logMinsStdToFinish = runner.fin_sum_log_std
          var dataPoints = produceDataPoints(logMinsToFinish, logMinsStdToFinish, ve_or_ju, undefined)
          return {
            type: 'line',
            label: "Static " + runner.leg + " " + runner.name,
            backgroundColor: color,
            borderColor: color,
            data: dataPoints,
            fill: false,
            pointRadius: 1
          }
        })
        */
    var verticalLineAnnotations = _.map(finishedRunners, function (runner) {
      var color = colors[colorNames[runner.leg - 1]]
      var realFinish = runner.lastControlTimestamp
      return {
        id: 'vline_' + runner.leg,
        type: 'line',
        mode: 'vertical',
        scaleID: 'x-axis-0',
        value: realFinish,
        borderColor: "grey",
        borderWidth: 2,
        label: {
          backgroundColor: color,
          content: formatTime(realFinish),
          enabled: true
        }
      }
    })
    var chartOptions = {
      //responsive: true,
      title: {
        display: true,
        text: teamId + " " + teamRunners[0].team
      },
      tooltips: {
        enabled: false,
        mode: 'index',
        intersect: false,
      },
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'minute',
            displayFormats: {
              minute: 'HH:mm'
            }
          },
          display: true,
          scaleLabel: {
            display: true,
            labelString: 'Kellonaika'
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: true,
            labelString: 'Maaliintulon todennäköisyys'
          }
        }]
      },
      annotation: {
        annotations: verticalLineAnnotations
      }
    }
    //Chart.defaults.line.spanGaps = true;
    var myLineChart = new Chart("chartjs-plot", {
      type: 'line',
      data: {
        datasets: teamDatasets.concat(staticDatasets)
      },
      options: chartOptions
    });

  }

  var searchParams = new URLSearchParams(window.location.search)
  var ve_or_ju = searchParams.get('race')
  if (ve_or_ju != "ve" && ve_or_ju != "ju") {
    throw Error("Unrecognized race.")
  }
  var resultsQueryParamsStr = ""
  var use2018LiveResultsWithRaceTime = searchParams.get('use2018LiveResultsWithRaceTime')
  if (use2018LiveResultsWithRaceTime) {
    if (use2018LiveResultsWithRaceTime.length != 8) {
      throw Error("Unrecognized use2018LiveResultsWithRaceTime.")
    }
    resultsQueryParamsStr = "?use2018LiveResultsWithRaceTime=" + use2018LiveResultsWithRaceTime
  }

  var teamId = parseInt(searchParams.get('team'))
  var url = "https://ecbnnyd5j6.execute-api.eu-west-1.amazonaws.com/dev/" + ve_or_ju + "/" + teamId + resultsQueryParamsStr;
  $.getJSON(url, function (runners) {
    showTeam(teamId, runners, ve_or_ju)
  });

</script>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
-->
</body>
</html>